/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.24 from the
 * contents of R.xs. Do not edit this file, edit R.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "R.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "RSCommon.h"
#include "ForeignReference.h"
#include "Converters.h"

static int RPerlDebug = 0;

char *argv[] = {"REmbeddedPerl", "--silent"};

Rboolean
isRPrimitive(SEXP val, SEXPTYPE *type)
{
 Rboolean is = FALSE;

 if(GET_LENGTH(GET_DIM(val))) {
  return(FALSE);
 }

 if(GET_LENGTH(GET_CLASS(val))) {
  return(FALSE);
 }
 
  *type = TYPEOF(val); 
 switch(*type) {
   case REALSXP:
   case LGLSXP:
   case STRSXP:
   case INTSXP:
     is = TRUE;
   default:
     break;
 }
/* if(is == TRUE && type) */

 return(is);
}

USER_OBJECT_
getFunctionId(SV *tmp, char **funcName)
{
 USER_OBJECT_ fun = NULL;
       if(sv_isobject(tmp)) {
        if(sv_derived_from(tmp, "RNamedFunctionReference")) {
           tmp = RPerl_getReferenceName(tmp);
           *funcName = SvPV(tmp, PL_na);
           fun = Rf_install((char *)funcName);
        } else if(sv_derived_from(tmp, "RReferences")) {
           fun = RPerl_getProxyValue(tmp);
           *funcName = "R function reference";
        } else {
          fprintf(stderr, "Incorrect reference type of object passed as first arg to R::call()\n");fflush(stderr);
          return(NULL);
        }
       } else if(SvPOK(tmp)) {
 	 char *name;
	 name = SvPV_nolen(tmp);
    /*
         name = SvPV(tmp, SvCUR(tmp)); 
    */
         if(!name) {
          fprintf(stderr, "Couldn't get name from Perl string\n");fflush(stderr);          
           return(NULL);
         }

         if(funcName)
   	    *funcName = name;
         fun = Rf_install((char *)name);
       } else {
         /* Really need a string here. So bail with an error. */
         fprintf(stderr, "Incorrect type of object passed as first arg to R::call()\n");fflush(stderr);
         return(NULL);
       }

   return(fun);
}



/*
 R_call is a general .R()-like function for calling R functions
 from Perl. An arbitray number of arguments can be passed.
*/
#line 96 "R.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 238 "R.c"

XS_EUPXS(XS_R_call); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_R_call)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 96 "R.xs"
      char *funcName = "?";
      int numArgs = 2;
      int errorOccurred;
      SV  *result, *sv, *tmp;
      USER_OBJECT_ e, fun, val;
      int i;
      SEXPTYPE Rtype;
      Rboolean addLocal;

#line 258 "R.c"
	SV *	RETVAL;
#line 107 "R.xs"
       numArgs = (items);

       tmp = ST(0);

       fun = getFunctionId(tmp, &funcName);
       if(fun == NULL || GET_LENGTH(fun) == 0) {
         fprintf(stderr, "Couldn't find function to be called\n");fflush(stderr);
         /*XXX Should we put an undef on the stack. */
         return;
       }

       PROTECT(fun);

       if(RPerlDebug)
        fprintf(stderr, "Calling R function name `%s', # arguments: %d\n", funcName, numArgs);fflush(stderr);

       PROTECT(e = allocVector(LANGSXP, numArgs));
       SETCAR(e, fun);

       if(numArgs > 1) {
       	 svtype type;
         SEXP next = CDR(e), arg;

         for(i = 1; i < numArgs ; i++) {
          tmp = ST(i);
          type = SvTYPE(tmp);
          arg = NULL_USER_OBJECT;

          if(RPerlDebug)
             fprintf(stderr, "%d) Arg type %d\n", i, type);fflush(stderr);

          if(tmp == &PL_sv_undef) {
             arg = NULL_USER_OBJECT;
          } else if (sv_isa(tmp, "RReferences")) {
             arg = RPerl_getProxyValue(tmp);
          } else if(SvROK(tmp)) {
             if(RPerlDebug)
               fprintf(stderr, "Got a reference to a value %d\n", SvTYPE(SvRV(tmp)));fflush(stderr);
             arg = fromPerl(tmp, TRUE);
       	  }  else if(SvIOK(tmp)){
             PROTECT(arg = NEW_INTEGER(1));
               INTEGER_DATA(arg)[0] = SvIV(tmp);
             UNPROTECT(1);    
          } else if(SvPOK(tmp)){
             PROTECT(arg = NEW_CHARACTER(1));
               SET_STRING_ELT(arg, 0, COPY_TO_USER_STRING(SvPV(tmp, PL_na)));
             UNPROTECT(1);    
          } else if(SvNOK(tmp)) {
             PROTECT(arg = NEW_NUMERIC(1));
               NUMERIC_DATA(arg)[0] = SvNV(tmp);
             UNPROTECT(1);    
          } else {
fprintf(stderr, "Didn't convert Perl argument %d\n", i);fflush(stderr);
          }
          SETCAR(next, arg);        
          next = CDR(next);
         }
       }

      if(RPerlDebug) {
        fprintf(stderr, "Calling R\n");fflush(stderr);
        Rf_PrintValue(e);
      }

      val = R_tryEval(e, R_GlobalEnv, &errorOccurred);
      if(errorOccurred) {
        fprintf(stderr, "Caught error in R::call()\n");fflush(stderr);
        UNPROTECT(2);
         /*XXX Throw error here! */
        return;
      }

      PROTECT(val);

      if(RPerlDebug)  {
        fprintf(stderr, "Performed the call, result has length %d\n", GET_LENGTH(val));fflush(stderr);
      }

      if(GIMME_V == G_VOID || val == NULL_USER_OBJECT || GET_LENGTH(val) == 0) {
         XPUSHs(&PL_sv_undef);
      } else if(isRPrimitive(val, &Rtype)) {
        EXTEND(SP,GET_LENGTH(val));
        if(RPerlDebug)  {
           fprintf(stderr, "Primitive, R type: %d, of length %d\n", (int)Rtype, GET_LENGTH(val));fflush(stderr);
           Rf_PrintValue(val);
        }

        for(i = 0; i < GET_LENGTH(val); i++) {
           sv = NULL;
           switch(Rtype) {
    	     case STRSXP:
    		sv = newSVpv(CHAR(STRING_ELT(val, i)), 0);
    	     break;
    	     case LGLSXP:
    		sv = newSViv(LOGICAL_DATA(val)[i]);
    	     break;
    	     case INTSXP:
    		sv = newSViv(INTEGER_DATA(val)[i]);
    	     break;
    	     case REALSXP:
    		sv = newSVnv(NUMERIC_DATA(val)[i]);
    	     break;
             default:
               sv = NULL;
           }
           if(sv) {
              PUSHs(sv_2mortal(sv));
           }
        }
      } else {
	 result = userLevelConversionToPerl(val);
	 if(result == NULL)
	     result = RPerl_createRProxy(val);
         XPUSHs(sv_2mortal(result));
      }

       UNPROTECT(3);
#line 378 "R.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_R_callWithNames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_R_callWithNames)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "func, argTable");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	func = ST(0)
;
	SV *	argTable = ST(1)
;
#line 231 "R.xs"
          /* 
           Allows an R function to be called with named arguments.
           The input
          */
      char *funcName; 
      int numArgs=0;
      int errorOccurred;
      SV  *result, *sv;
      USER_OBJECT_ e, val;
      int i;
      I32 len;
      SEXPTYPE Rtype;
      Rboolean addLocal;
      svtype argType;
#line 413 "R.c"
	SV *	RETVAL;
#line 247 "R.xs"
      if(SvROK(argTable))
         argTable = SvRV(argTable);

       argType = SvTYPE(argTable);

       numArgs = hv_iterinit((HV*)argTable);

       if(RPerlDebug)
   	   fprintf(stderr, "# of named arguments %d\n", numArgs);fflush(stderr);

       PROTECT(e = allocVector(LANGSXP, numArgs+1));

       SETCAR(e, getFunctionId(func, &funcName));

       if(numArgs > 0) {
       	 SV *tmp;
       	 svtype type;
         char *key;
         SEXP next = CDR(e), arg;

         for(i = 0; i < numArgs ; i++) {
	   Rboolean doUnprotect = 1;
           tmp = hv_iternextsv((HV*)argTable, &key, &len);
           type = SvTYPE(tmp);

           arg = NULL_USER_OBJECT;
	   doUnprotect = 1; 

           if(RPerlDebug)
             fprintf(stderr, "%d) %s  Arg type %d\n", i, key, type);fflush(stderr);

          if (sv_isa(tmp, "RReferences"))  {
            arg = RPerl_getProxyValue(tmp);
            doUnprotect = 0;
          } else if(tmp == &PL_sv_undef || !SvOK(tmp)) { /* &PL_sv_undef undefined */
	     doUnprotect = 0;
          } else if (SvROK(tmp)) {
            if(RPerlDebug)
              fprintf(stderr, "Got a reference to a value %d\n", (int) SvTYPE(SvRV(tmp)));fflush(stderr);
            arg = fromPerl(tmp, TRUE); 
	    doUnprotect = 0;	
       	  }  else if(SvIOK(tmp)){
             PROTECT(arg = NEW_INTEGER(1));
             INTEGER_DATA(arg)[0] = SvIV(tmp);
          } else if(SvPOK(tmp)){
             PROTECT(arg = NEW_CHARACTER(1));
             SET_STRING_ELT(arg, 0, COPY_TO_USER_STRING(SvPV(tmp, PL_na)));
          } else if(SvNOK(tmp)){
             PROTECT(arg = NEW_NUMERIC(1));
             NUMERIC_DATA(arg)[0] = SvNV(tmp);
          } else {
             doUnprotect = 0;
          }


          SETCAR(next, arg);        
          if(key && key[0])
             SET_TAG(next, Rf_install(key));

          if(doUnprotect)
             UNPROTECT(1);
          next = CDR(next);
         }
       }


      if(RPerlDebug)
          Rf_PrintValue(e);
      val = R_tryEval(e, R_GlobalEnv, &errorOccurred);
      if(errorOccurred) {
        UNPROTECT(1);
         /*XXX Throw error here! */
        return;
      }
      PROTECT(val);

      if(GIMME_V == G_VOID || val == NULL_USER_OBJECT || GET_LENGTH(val) == 0) {
         XPUSHs(&PL_sv_undef);
      } else if(isRPrimitive(val, &Rtype)) {
        EXTEND(SP,GET_LENGTH(val));
        for(i = 0; i < GET_LENGTH(val); i++) {
           switch(Rtype) {
    	     case STRSXP:
    		sv = newSVpv(CHAR(STRING_ELT(val, i)), 0);
    	     break;
    	     case LGLSXP:
    		sv = newSViv(LOGICAL_DATA(val)[i]);
    	     break;
    	     case INTSXP:
    		sv = newSViv(INTEGER_DATA(val)[i]);
    	     break;
    	     case REALSXP:
    		sv = newSVnv(NUMERIC_DATA(val)[i]);
    	     break;
             default:
               sv = NULL;
           }
           if(sv)
              XPUSHs(sv_2mortal(sv));
        }
      } else {
	 result = userLevelConversionToPerl(val);
	 if(result == NULL) {
           /* Rf_PrintValue(val) ; XXX */
           result = RPerl_createRProxy(val);
         }
         XPUSHs(sv_2mortal(result));
      }

       UNPROTECT(2);
#line 526 "R.c"
	PUTBACK;
	return;
    }
}

#ifdef WITH_R_IN_PERL
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_R_initRSession); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_R_initRSession)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 366 "R.xs"
   char *defaultArgs[] = {"REmbeddedPerl"};
   char **args;
   int numArgs, i;
#line 548 "R.c"
#line 370 "R.xs"
  /* We should check that we haven't started this already. */
      numArgs = (items);
      if(numArgs > 0) {
        args = (char **)calloc(numArgs + 1, sizeof(char *));
        args[0] = strdup("REmbeddedPerl");
        for(i = 0; i < numArgs; i++) {
          args[i+1] = strdup(SvPV(ST(i), PL_na));
        }
        numArgs++;
      } else {
        numArgs = sizeof(defaultArgs)/sizeof(defaultArgs[0]);
        args = (char **)calloc(numArgs, sizeof(char *));
        for(i = 0; i < numArgs; i++) {
          args[i] = strdup(defaultArgs[i]);
        }
      }
      Rf_initEmbeddedR(numArgs, args);
      /* setREmbeddedInPerl((Rboolean) 1); */
#line 568 "R.c"
	PUTBACK;
	return;
    }
}

#else
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_R_initRSession); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_R_initRSession)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 393 "R.xs"
#line 587 "R.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_R_eval); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_R_eval)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cmd");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	cmd = (char *)SvPV_nolen(ST(0))
;
#line 404 "R.xs"
         SEXPTYPE Rtype;
         SV  *result, *sv;
         int i;
         USER_OBJECT_ e, tmp, val;
         int errorOccurred;

#line 613 "R.c"
	SV *	RETVAL;
#line 412 "R.xs"
      PROTECT(e = allocVector(LANGSXP, 2));
      SETCAR(e, Rf_install("parseEval"));
      SETCAR(CDR(e), tmp = NEW_CHARACTER(1));
      SET_STRING_ELT(tmp, 0, COPY_TO_USER_STRING(cmd));

      if(RPerlDebug) {
        fprintf(stderr, "Evaluating command %s\n", cmd); fflush(stderr);
        Rf_PrintValue(e);
      }

      val = R_tryEval(e, R_GlobalEnv, &errorOccurred);
      if(errorOccurred) {
        UNPROTECT(1);
         /*XXX Throw error here! */
        return;
      }
      PROTECT(val);
      if(RPerlDebug) {
        fprintf(stderr, "Got the answer\n"); fflush(stderr);
        Rf_PrintValue(val);
      }

      if(GIMME_V == G_VOID || val == NULL_USER_OBJECT || GET_LENGTH(val) == 0) {
         XPUSHs(&PL_sv_undef);
      } else if(isRPrimitive(val, &Rtype)) {
        EXTEND(SP,GET_LENGTH(val));
      if(RPerlDebug) {
       fprintf(stderr, "Converting R primitive type to Perl: len = %d, type = %d\n",GET_LENGTH(val), Rtype);fflush(stderr); 
      }
        for(i = 0; i < GET_LENGTH(val); i++) {
           switch(Rtype) {
    	     case STRSXP:
    		sv = newSVpv(CHAR(STRING_ELT(val, i)), 0);
    	     break;
    	     case LGLSXP:
    		sv = newSViv(LOGICAL_DATA(val)[i]);
    	     break;
    	     case INTSXP:
    		sv = newSViv(INTEGER_DATA(val)[i]);
    	     break;
    	     case REALSXP:
    		sv = newSVnv(NUMERIC_DATA(val)[i]);
    	     break;
             default:
               sv = NULL;
           }
           if(sv)
              XPUSHs(sv_2mortal(sv));
        }
      } else {
	 result = userLevelConversionToPerl(val);
	 if(result == NULL)
           result = RPerl_createRProxy(val);
         XPUSHs(sv_2mortal(result));
      }

      UNPROTECT(2);
#line 673 "R.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_R_setConverter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_R_setConverter)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "match, converter, desc, toPerl");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	match = ST(0)
;
	SV *	converter = ST(1)
;
	char *	desc = (char *)SvPV_nolen(ST(2))
;
	int	toPerl = (int)SvIV(ST(3))
;
#line 481 "R.xs"
	int autoArray = 1, index;
#line 699 "R.c"
	int	RETVAL;
	dXSTARG;
#line 483 "R.xs"
	  index = addPerlConverterRoutine(match, converter, toPerl, desc, autoArray);
	  PUSHi(sv_2mortal(newSViv(index)));
#line 705 "R.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_R_deleteRReference); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_R_deleteRReference)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	ref = ST(0)
;
#line 493 "R.xs"
	int ok;
#line 725 "R.c"
	int	RETVAL;
	dXSTARG;
#line 495 "R.xs"
	  ok = RPerl_discardRProxy(ref);
	  PUSHi(sv_2mortal(newSViv(ok)));
#line 731 "R.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_R_setDebug); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_R_setDebug)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "n");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	int	n = (int)SvIV(ST(0))
;
	SV *	RETVAL;
#line 505 "R.xs"
         RPerlDebug = n;
         XPUSHs(sv_2mortal(newSViv(RPerlDebug)));
#line 753 "R.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_R_library); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_R_library)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "libName");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	libName = (char *)SvPV_nolen(ST(0))
;
#line 516 "R.xs"
      USER_OBJECT_ e, tmp;
      SV *sv;
      int errorOccurred;

#line 776 "R.c"
	SV *	RETVAL;
#line 521 "R.xs"
       PROTECT(e = allocVector(LANGSXP, 2));
       SETCAR(e, Rf_install("library"));
       SETCAR(CDR(e), tmp = NEW_CHARACTER(1));
       SET_STRING_ELT(tmp, 0, COPY_TO_USER_STRING(libName));
       R_tryEval(e, R_GlobalEnv, &errorOccurred);
       UNPROTECT(1);
       sv = newSViv(errorOccurred == 0);      
       XPUSHs(sv_2mortal(sv));
#line 787 "R.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_R_rnorm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_R_rnorm)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "n");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	int	n = (int)SvIV(ST(0))
;
#line 538 "R.xs"
      SEXP in, out, e, fun;
      int i;
#line 808 "R.c"
	double *	RETVAL;
#line 541 "R.xs"
       PROTECT(in = NEW_INTEGER(1));
       INTEGER_DATA(in)[0] = n;
       PROTECT(e = allocVector(LANGSXP,2));
       PROTECT(fun = Rf_findFun(Rf_install("rnorm"),  R_GlobalEnv));
        SETCAR(e, fun);
        SETCAR(CDR(e), in);
        out = eval(e, R_GlobalEnv);
        EXTEND(SP, n);
        for(i = 0; i < n; i++)
          PUSHs(sv_2mortal(newSVnv(NUMERIC_DATA(out)[i])));
#line 821 "R.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_R); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_R)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        (void)newXSproto_portable("R::call", XS_R_call, file, ";@");
        (void)newXSproto_portable("R::callWithNames", XS_R_callWithNames, file, "$$");
#if XSubPPtmpAAAA
        (void)newXSproto_portable("R::initRSession", XS_R_initRSession, file, ";@");
#endif
#if XSubPPtmpAAAB
        (void)newXSproto_portable("R::initRSession", XS_R_initRSession, file, ";@");
#endif
        (void)newXSproto_portable("R::eval", XS_R_eval, file, "$");
        (void)newXSproto_portable("R::setConverter", XS_R_setConverter, file, "$$$$");
        (void)newXSproto_portable("R::deleteRReference", XS_R_deleteRReference, file, "$");
        (void)newXSproto_portable("R::setDebug", XS_R_setDebug, file, "$");
        (void)newXSproto_portable("R::library", XS_R_library, file, "$");
        (void)newXSproto_portable("R::rnorm", XS_R_rnorm, file, "$");

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#line 868 "R.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

